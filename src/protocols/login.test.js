// @flow
import {
  describe, it, before, after,
} from 'mocha';
import { Entry } from '../claim/entry';
import { NameResolver, testNamesJSON } from '../api-client/name-resolver';
import { Discovery, testEntitiesJSON } from '../api-client/discovery';
import { SignedPacketVerifier } from './login';

const chai = require('chai');

const { expect } = chai;

const snarkjs = require('snarkjs');
const iden3 = require('../index');
const smt = require('../sparse-merkle-tree/sparse-merkle-tree');

const { bigInt } = snarkjs;
// const relayKOpAddr = '0xe0fbce58cfaa72812103f003adce3f284fe5fc7c';
// const relayKOp = '117f0a278b32db7380b078cdb451b509a2ed591664d1bac464e8c35a90646796';
const relayKOp = '80644d4e0b42eb39f0a3999e5c740030ae63b9931bb6cddab6adbd069fb88713';
// const usrAddr = '0x308eff1357e7b5881c00ae22463b0f69a0d58adb';
// const usrAddr = '1pnWU7Jdr4yLxp1azs1r1PpvfErxKGRQdcLBZuq3Z';
const usrAddr = '11AVZrKNJVqDJoyKrdyaAgEynyBEjksV5z2NjZoPxf';

// following proofEthName and proofKSign are generated by go-iden3
const proofEthName = {
  ethName: 'testName@iden3.eth',
  proofAssignName: {
    proofs: [{
      mtp0: "0x00010000000000000000000000000000000000000000000000000000000000010c700bd97fc58c91d9a4d1ebfb3d774f5b7e20938571b9775a4ec83ccd4578e8",
      mtp1: "0x030100000000000000000000000000000000000000000000000000000000000122f1509d93aea54670531f4780d04291061ea8fa944e9a421a97f0429022693208e0c319c5ab756f8015b8c52efb43ca6e184275bc02fe40b6405eff8a7b14a21cc19f80bc1db2afc0e81d17fe336ce4464feafdcf797115f9ee9b0c1b576d63",
      root: "0x1da1b574a58771e5b00f83fccd9c0625a490b87ad760072b47322638085f32ac",
      aux: null
    }],
    leaf: "0x0000000000000000000000000000000000000000000000000000000000000000000000d119a5c0b9fe1659620b8a635024d5ed0fed3cc9f5f20403a9ff480de400178118069763dbe18ad9c512b09b4f9a9b7ae14c4ead00200ceabdcbac85950000000000000000000000000000000000000000000000000000000000000003",
    date: 1567678236,
    signature: "a3456b0c848eee0153b8e25de19a849b750c3790a7b64d29a841e9c8240d978b56b6c7705b38a96a80f5f5e97f117327fba713738a59c8aa6b598704b3145e01",
    signer: "113kyY52PSBr9oUqosmYkCavjjrQFuiuAw47FpZeUf"
    },
};

// relay: 11AVZrKNJVqDJoyKrdyaAgEynyBEjksV5z2NjZoWij
// user: 1pnWU7Jdr4yLxp1azs1r1PpvfErxKGRQdcLBZuq3Z

const proofKSign = {
  proofs: [{
    mtp0: "0x00020000000000000000000000000000000000000000000000000000000000020bf5a5e8ad9b4019995f156cc33c662a7ed06b5f8a90cba2b107e43dda501fbc",
    mtp1: "0x030300000000000000000000000000000000000000000000000000000000000628361d9c28398d5c9cf6752f2036580b07a8174e4ba67ea691e908020aebbb3d0154ceb503b9c020c80b3b9575e92dde5cc2072965459910b0f5740b211b6f77117e8519d6ec3b4d16440fbec03bddd43c7e07a5e018a0eb73d52b866529a2fc021a76d5f2cdcf354ab66eff7b4dee40f02501545def7bb66b3502ae68e1b781",
    root: "0x268c9d5a2eed543bcfc7b9688e1aa285036037f5b8b78c522e7cc7f0493dd431",
    aux: {
      version: 0,
      era: 0,
      id: "11AVZrKNJVqDJoyKrdyaAgEynyBEjksV5z2NjZoPxf"
    }
  }, {
    mtp0: "0x0000000000000000000000000000000000000000000000000000000000000000",
    mtp1: "0x030000000000000000000000000000000000000000000000000000000000000008e0c319c5ab756f8015b8c52efb43ca6e184275bc02fe40b6405eff8a7b14a21cc19f80bc1db2afc0e81d17fe336ce4464feafdcf797115f9ee9b0c1b576d63",
    root: "0x0c700bd97fc58c91d9a4d1ebfb3d774f5b7e20938571b9775a4ec83ccd4578e8",
    aux: null
  }],
  leaf: "0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001e730fbf398dacc09c2bd5316f0a16563faa6d5750825e520655ceec440804340000000000000000000000000000000000000001000000000000000000000001",
  date: 1567678236,
  signature: "324a94b4f839b4f90ac01da0237ecaafba140505a4d55477335a7d8cdad9d62d755edcbae8fa780edead02bf57fe14132a570198d09c4a9412df2c1061075e04",
  signer: "113kyY52PSBr9oUqosmYkCavjjrQFuiuAw47FpZeUf"
};

describe('[protocol]', () => {
  let db;
  let kc;
  let kOperational;
  let signedPacketVerifier;

  before('initialize objects', () => {
    const discovery = new Discovery(testEntitiesJSON);
    const nameResolver = new NameResolver(testNamesJSON);
    signedPacketVerifier = new SignedPacketVerifier(discovery, nameResolver);
    db = new iden3.Db.LocalStorage();
    kc = new iden3.KeyContainer(db);
    kc.unlock('pass');
  });

  after('lock key container', () => {
    kc.lock();
  });

  it('create operation key', () => {
    const mnemonic = 'enjoy alter satoshi squirrel special spend crop link race rally two eye';
    kc.setMasterSeed(mnemonic);
    // const keys = kc.createKeys();
    // kOperational = keys.kOp;
    kOperational = kc.importBabyKey('9b3260823e7b07dd26ef357ccfed23c10bcef1c85940baa3d02bbf29461bbbbe');
  });

  it('test bigint', () => {
    // check that node version supports shiftLeft on bigInt
    bigInt(8).toString();
    bigInt(8).shl(2);
  });

  it('test check proof', () => {
    // const id = '0x393939393939393939393939393939393939393a';
    const id = '11AVZrKNJVqDJoyKrdyaAgEynyBEjksV5z2NjZoPxf';
    const mt = new smt.SparseMerkleTree(db, id, 140);
    // Add 10 test entries to sparse merkle tree
    for (let i = 0; i < 8; i++) {
      const entry = Entry.newFromBigInts(bigInt(0), bigInt(0), bigInt(0), bigInt(i));
      mt.addEntry(entry);
    }
    const leaf = '0x'
    + '0000000000000000000000000000000000000000000000000000000000000000'
    + '000000000000000000000000393939393939393939393939393939393939393a'
    + '00d67b05d8e2d1ace8f3e84b8451dd2e9da151578c3c6be23e7af11add5a807a'
    + '0000000000000000000000000000000000000000000000010000000000000003';
    // Add leaf to sparse merkle tree
    const entry = Entry.newFromHex(leaf);
    mt.addEntry(entry);
    // generate proof
    const proofBuff = mt.generateProof(new Entry(Buffer.alloc(32), Buffer.alloc(32), entry.elements[2], entry.elements[3]).hiBigInt());
    const proof = iden3.utils.bytesToHex(proofBuff);
    const root = iden3.utils.bytesToHex(mt.root);
    const verified = smt.checkProof(root, proof, iden3.utils.bytesToHex(entry.hi()), iden3.utils.bytesToHex(entry.hv()));
    expect(verified).to.be.equal(true);
  });

  it('verify ProofClaimFull (proofClaimAssignName & proofKSign)', () => {
    const assignNameVerified = iden3.protocols.verifyProofClaimFull(proofEthName.proofAssignName, relayKOp);
    expect(assignNameVerified).to.be.equal(true);

    const ksignVerified = iden3.protocols.verifyProofClaimFull(proofKSign, relayKOp);
    expect(ksignVerified).to.be.equal(true);
  });

  it('newRequestIdenAssert & signIdenAssertV01 & verifySignedPacket', () => {
    const origin = 'domain.io';
    // login backend:
    const nonceDB = new iden3.protocols.nonceDB.NonceDB();
    const signatureRequest = iden3.protocols.login.newRequestIdenAssert(nonceDB, origin, 2 * 60);

    // check that the nonce is in the nonceDB
    expect(nonceDB.search(signatureRequest.body.data.challenge)).to.be.not.equal(undefined);

    // identity wallet:
    const signedPacket = iden3.protocols.login.signIdenAssertV01(signatureRequest, usrAddr,
      { ethName: proofEthName.ethName, proofAssignName: proofEthName.proofAssignName },
      kc, kOperational, proofKSign, 3600 * 60);

    // login backend:
    const res = signedPacketVerifier.verifySignedPacketIdenAssert(signedPacket, nonceDB, origin);
    if (res == null) { return; }

    // check that the nonce returned when deleting the nonce of the signedPacket, is the same
    // than the nonce of the signatureRequest
    expect(res.nonceObj.nonce).to.be.equal(signatureRequest.body.data.challenge);

    // nonce must not be more in the nonceDB
    expect(nonceDB.search(res.nonceObj.nonce)).to.be.equal(undefined);

    expect(res.ethName).to.be.equal(proofEthName.ethName);
    expect(res.id).to.be.equal(usrAddr);

    // check that an already checked signedPacket is not more longer available to be verified
    expect(() => {
      signedPacketVerifier.verifySignedPacketIdenAssert(signedPacket, nonceDB, origin);
    }).to.throw('Challenge nonce not found in the DB');
  });
});
