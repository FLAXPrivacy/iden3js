// @flow
import {
  describe, it, before, after,
} from 'mocha';
import { Entry } from '../claim/entry/entry';
import { NameResolver, testNamesJSON } from '../http/name-resolver';
import { Discovery, testEntitiesJSON } from '../http/discovery';
import { SignedPacketVerifier } from './login';

const chai = require('chai');

const { expect } = chai;

const snarkjs = require('snarkjs');
const iden3 = require('../index');
const smt = require('../sparse-merkle-tree/sparse-merkle-tree');

const { bigInt } = snarkjs;
const relayKOpAddr = '0xe0fbce58cfaa72812103f003adce3f284fe5fc7c';
const usrAddr = '0x308eff1357e7b5881c00ae22463b0f69a0d58adb';

// following proofEthName and proofKSign are generated by go-iden3
const proofEthName = {
  ethName: 'usertest@iden3.io',
  proofAssignName: {
    signer: '1pnWU7Jdr4yLxp1azs1r1PpvfErxKGRQdcLBZuq3Z',
    date: 1557929059,
    leaf: '0x00000000000000000000000000000000000000000000000000000000000000000000041c980d8faa54be797337fa55dbe62a7675e0c83ce5383b78a04b26b9f40063ea0983a784a474e012c2ce392b45296419d9b57f91533c579a691db028f30000000000000000000000000000000000000000000000000000000000000003',
    proofs: [
      {
        aux: null,
        mtp0: '0x000300000000000000000000000000000000000000000000000000000000000401460efcd144ff6e92244cc51c59cb322886599fc2092b9d4b09b5bce79ddfda',
        mtp1: '0x010200000000000000000000000000000000000000000000000000000000000226620ae90f5af5a98b0fffc2b2aaf0b1ba00784b5d3731e27d16732a05393a22',
        root: '0x1820d7d5639e770c1e8ee4583b0bc626c5f61af24d3c358b4cc06faef2802ced',
      },
    ],
    signature: '0x5c32cd793b7deae62188d631c777f9867faac459ba6745c7c182191cf6bda81e3c5eb28843682cf658dc7e6d877d67dfedd8760be35f5d7a9e09eac187d223341b',
  },
};

const proofKSign = {
  signer: '0x0123456789abcdef0123456789abcdef01234567',
  date: 1551457426,
  leaf: '0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003c2e48632c87932663beff7a1f6deb692cc61b041262ae8f310203d0f5ff50000000000000000000000000000000000007833000000000000000000000004',
  proofs: [
    {
      aux: {
        version: 0,
        era: 0,
        idAddr: '0x308eff1357e7b5881c00ae22463b0f69a0d58adb',
      },
      mtp0: '0x0000000000000000000000000000000000000000000000000000000000000000',
      mtp1: '0x030000000000000000000000000000000000000000000000000000000000000028f8267fb21e8ce0cdd9888a6e532764eb8d52dd6c1e354157c78b7ea281ce801541a6b5aa9bf7d9be3d5cb0bcc7cacbca26242016a0feebfc19c90f2224baed',
      root: '0x1d9d41171c4b621ff279e2acb84d8ab45612fef53e37225bdf67e8ad761c3922',
    }, {
      aux: null,
      mtp0: '0x0000000000000000000000000000000000000000000000000000000000000000',
      mtp1: '0x030000000000000000000000000000000000000000000000000000000000000021c9cceb8a61605050a029cecda7e36eeaffef11910778b3e5ea32f79659cee125451237d9133b0f5c1386b7b822f382cb14c5fff612a913956ef5436fb6208a',
      root: '0x0b109c78f2679a405cc0b5a8d999129ee4429e86a986b8001e0a4df61c359690',
    },
  ],
  signature: '0xb0ef961c13cfa373fb40e7de7e523eb2571708e0852425cf1878a9f1b04f04ab42952f1d9525ea04be867fed7b27aca1caf1ea1422eceedbd61d641537a94ae31b',
};

describe('[protocol]', () => {
  let db;
  let kc;
  let kOperational;
  let signedPacketVerifier;

  before('initialize objects', () => {
    const discovery = new Discovery(testEntitiesJSON);
    const nameResolver = new NameResolver(testNamesJSON);
    signedPacketVerifier = new SignedPacketVerifier(discovery, nameResolver);
    db = new iden3.Db();
    kc = new iden3.KeyContainer('localStorage', db);
    kc.unlock('pass');
  });

  after('lock key container', () => {
    kc.lock();
  });

  it('create operation key', () => {
    const mnemonic = 'enjoy alter satoshi squirrel special spend crop link race rally two eye';
    kc.generateMasterSeed(mnemonic);
    const mnemonicDb = kc.getMasterSeed();
    kc.generateKeySeed(mnemonicDb);
    const { keySeed, pathKey } = kc.getKeySeed();
    const objectKeys = kc.generateKeysFromKeyPath(keySeed, pathKey);
    const { keys } = objectKeys;
    const kSign = keys[1];
    kOperational = kSign;
  });

  it('test bigint', () => {
    // check that node version supports shiftLeft on bigInt
    bigInt(8).toString();
    bigInt(8).shl(2);
  });

  it('test check proof', () => {
    const idAddr = '0x393939393939393939393939393939393939393a';
    const mt = new smt.SparseMerkleTree(db, idAddr, 140);
    // Add 10 test entries to sparse merkle tree
    for (let i = 0; i < 8; i++) {
      const claim = [bigInt(0), bigInt(0), bigInt(0), bigInt(i)];
      mt.addClaim(claim);
    }
    const leaf = '0x'
    + '0000000000000000000000000000000000000000000000000000000000000000'
    + '000000000000000000000000393939393939393939393939393939393939393a'
    + '00d67b05d8e2d1ace8f3e84b8451dd2e9da151578c3c6be23e7af11add5a807a'
    + '0000000000000000000000000000000000000000000000010000000000000003';
    // Add leaf to sparse merkle tree
    const entry = Entry.newFromHex(leaf);
    mt.addClaim(iden3.utils.getArrayBigIntFromBuffArrayBE(entry.elements));
    // generate proof
    const proofBuff = mt.generateProof(iden3.utils.getArrayBigIntFromBuffArrayBE([entry.elements[2], entry.elements[3]]));
    const proof = iden3.utils.bytesToHex(proofBuff);
    const root = iden3.utils.bytesToHex(mt.root);
    const verified = smt.checkProof(root, proof, iden3.utils.bytesToHex(entry.hi()), iden3.utils.bytesToHex(entry.hv()));
    expect(verified).to.be.equal(true);
  });

  it('verify ProofClaimFull (proofClaimAssignName & proofKSign)', () => {
    const assignNameVerified = iden3.protocols.verifyProofClaimFull(proofEthName.proofAssignName, relayKOpAddr);
    expect(assignNameVerified).to.be.equal(true);

    const ksignVerified = iden3.protocols.verifyProofClaimFull(proofKSign, relayKOpAddr);
    expect(ksignVerified).to.be.equal(true);
  });

  it('newRequestIdenAssert & signIdenAssertV01 & verifySignedPacket', () => {
    const origin = 'domain.io';
    // login backend:
    const nonceDB = new iden3.protocols.nonceDB.NonceDB();
    const signatureRequest = iden3.protocols.login.newRequestIdenAssert(nonceDB, origin, 2 * 60);

    // check that the nonce is in the nonceDB
    expect(nonceDB.search(signatureRequest.body.data.challenge)).to.be.not.equal(undefined);

    // identity wallet:
    const signedPacket = iden3.protocols.login.signIdenAssertV01(signatureRequest, usrAddr,
      { ethName: proofEthName.ethName, proofAssignName: proofEthName.proofAssignName },
      kc, kOperational, proofKSign, 3600 * 60);

    // login backend:
    const res = signedPacketVerifier.verifySignedPacketIdenAssert(signedPacket, nonceDB, origin);
    if (res == null) { return; }

    // check that the nonce returned when deleting the nonce of the signedPacket, is the same
    // than the nonce of the signatureRequest
    expect(res.nonceObj.nonce).to.be.equal(signatureRequest.body.data.challenge);

    // nonce must not be more in the nonceDB
    expect(nonceDB.search(res.nonceObj.nonce)).to.be.equal(undefined);

    expect(res.ethName).to.be.equal(proofEthName.ethName);
    expect(res.idAddr).to.be.equal(usrAddr);

    // check that an already checked signedPacket is not more longer available to be verified
    const res2 = signedPacketVerifier.verifySignedPacketIdenAssert(signedPacket, nonceDB, origin);
    expect(res2).to.be.equal(undefined);
  });
});
